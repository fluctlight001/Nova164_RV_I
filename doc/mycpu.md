# cpu 技术文档
## 框架结构
mycpu
├── EX.v                          --执行单元    
├── ID.v                          --译码单元    
├── IF.v                          --取指单元    
├── MEM.v                         --访存单元    
├── WB.v                          --写回单元    
├── alu.v                         --算数逻辑单元    
├── bru.v                         --跳转处理单元    
├── decoder_i.v       
├── lib                           --译码器单元（模块化）    
│   ├── decoder_2_4.v   
│   ├── decoder_3_8.v   
│   ├── decoder_4_16.v    
│   ├── decoder_5_32.v    
│   └── decoder_6_64.v    
├── lsu.v                         --访存单元    
├── regfile.v                     --寄存器组    
└── script    
    ├── decoder   
    ├── decoder.cpp   
    └── out   

## CTRL
ctrl模块控制了cpu流水段的暂停与传输，L

## IF
取指 (Fetch) 阶段接受跳转指令的控制与数据，并根据跳转控制改变pc结果，同时向存储器发出取指请求，指令返回的结果会交给译码逻辑。

由于位数为64位，因此每一次访问指令存储器会获得64位宽的数据（两条指令）

### 控制逻辑一览
| 信号名    | 无效时的效果（置0）    | 有效时的效果（置1）    |
|---------------- | --------------- | --------------- |
| pc_valid    | pc无效，不进行存储器使能    | pc有效，进行存储器使能    |
| br_e   | 发生分支跳转   | 不发生分支跳转   |

| 名称   | 意义    |
|--------------- | --------------- |
| pc   | 当前指令pc   |
| pc_nxt   | 下一条pc   |
| br_addr  | 跳转pc    |

### 数据通路一览
## ID
译码 (Decode) 阶段接收指令对齐缓冲给出的指令进行译码，译码后的结果会进入到后端执行部分。同时译码阶段也承担了对寄存器组的单元模块，提供对寄存器的读写功能。

因此译码器包含两个单元，一个是作为```decoder_i.v```文件代表的主译码单元，一个是以```regfile.v```文件代表寄存器组单元。

### 译码部分
#### 控制逻辑一览
| 信号名    | 无效时的效果（置0）    | 有效时的效果（置1）    |
|---------------- | --------------- | --------------- |
| sel_src1[0]    | 第一个操作数是0/来自于寄存器    |  第一个ALU操作数来自于PC    |
| sel_sec1[1]    | 第一个ALU操作数来自于寄存器    | 第一个ALU操作数是0    |
| sel_src2   | 第二个ALU操作数来自于寄存器  | 第二个ALU操作数来自于立即数   |
| sel_rf_res[0]   | 无 | ex的结果来自分支结果   |
| sel_rf_res[1]   | Item2.4   | Item3.4   |
| sel_rf_res[2]   |           |           |
| alu_op          | alu模块控制信号，细节记录在alu中 |           |
| bru_op          |           |           |
| lsu_op          |           |           |
| csr_op          |           |           |
| sel_imm         | 立即数选择单元 |    | 
| rf_we           | 指令不写寄存器| 指令写入寄存器 |
| wb_rf_we        | 回写写入寄存器 | 回写不写入寄存器 |

#### 数据通路一览
| 名称   | 意义    |
|--------------- | --------------- |
| rs1,rs2   | 两个读寄存器的端口号   |
|    | 两个读端口寄存器的内容   |
| imm   | 立即数内容   |
| rf_waddr   | 寄存器写的端口号   |
| wb_rf_waddr | 回写的寄存器地址 |
| wb_rf_wdata | 回写的寄存器内容 |
| pc_r     |  发送到的pc |


### 寄存器堆
寄存器堆已经对写后读相关进行解决

## EX
执行阶段包含ALU，BRU，LSU三个功能单元。并将计算结果提交到写回级，同时对数据存储器进行访问操作。读数据时，数据存储器将数据提交到写回级。

### ALU
ALU主要执行算数运算。

### BRU
BRU单元负责跳转处理，通过具体的跳转指令和操作数运算结果返回是否发生跳转与跳转地址。*这里有一个pc+4，但建议修改*

### LSU
由于访存操作的特点是会一次操作一个字（64位）的数据，对于 load 操作，会直接读取一个字，对于 store 操作，可以通过写使能的选择决定写哪一个字节。但无论是哪种操作，对于我们的访存地址而言，需要让我们的地址处以8并取整（后三位置0）。

对于取出来的数据，由于访存指令并不一定选择这个字，也可能是半字或字节，这个时候我们需要的数据在一个字的哪个位置都有可能，因此需要进行一个字节使能。

如何进行字节使能和存储访问（地址转换与地址计算）都封装到了 LSU 模块内，方便使用。

> ps: 这里的地址计算如果是我的话可能会考虑放在alu模块里

## MEM
